<!DOCTYPE html>
<html>
<head>
<style>
canvas, #stats{

	border: 1px solid black;
}

canvas{
	background: #2B6E36;
}
#stats{
	background: #003D99;
}

</style>
</head>
<body>

<canvas id="ctx" width="500" height="500"></canvas>
<canvas id="stats" width="200" height="500"></canvas>
 
<script>

var ctx = document.getElementById("ctx").getContext("2d");
var stats = document.getElementById("stats").getContext("2d");
var currentActiveWave = 0;
var globalTimer = (new Date()).getTime();
var outBoundaries = 525; //el ancho y alto de la pantalla es 500, por eso fuera es un poco mas alla de 500
var fps = 10;
var C_HEIGHT = 500;
var C_WIDTH = 500;
var selectedTower;

</script>

<script src="js/player_ent.js"></script>
<script src="js/wave_ent.js"></script>
<script src="js/sprite.js"></script>
<script src="js/enemy_ent.js"></script>
<script src="js/towers_ent.js"></script>
<script src="js/ghostTower_ent.js"></script>
<script src="js/bullet_ent.js"></script>
<script src="js/genMap_ent.js"></script>
<script src="js/docFunctions.js"></script>
<script src="js/drawFunctions.js"></script>

<script>
map1 = genMap();
waves = []; 
enemies = [];
towers = [];
towersForStats = [];
iceTowers = [];
gTower = ghostTower(-50,-50); //posx, posy
player = player();


var imagen = new Image();
imagen.src = "img/monster2.png";
frameIndex = 0;
tickCount = 0;
ticksPerFrame = 100;
numberOfFrames = 4 ;
sprwidth = 160;
sprheight = 40;

towersForStats.push(tower(0, "archer",  0, 0, 75, "red", 4, 2 , 200, 250));
towersForStats.push(tower(0, "cannon", 0, 0, 50, "orange", 4, 10 ,1000, 600));
towersForStats.push(iceTower(0, "ice", 0, 0, 35, "#3399ff" /*Celeste hielo*/, 0, .8 ,0, 1000));

window.addEventListener('focus',setInterval(update,fps)); //update solo se debe ejecutar si la tab esta visible


function update(){
	stats.clearRect(0,0,200,500);
	drawStats(player.gold, player.lives);
	drawTowerOptions(player.gold);
	
	ctx.clearRect(0,0,500,500);
	
	

	drawMap(map1);
	drawPlayButton();
	
	if (waves[currentActiveWave] != undefined && waves[currentActiveWave].active){
	
		for (var key in towers)
		{
			towers[key].setUsed();
		}
	
		if ( (globalTimer - waves[currentActiveWave].lastCreatedDate) > waves[currentActiveWave].spawnTime &&
		waves[currentActiveWave].amountEnemies > waves[currentActiveWave].enemies.length && waves[currentActiveWave].keepCreating)
		{
		
			waves[currentActiveWave].generateEnemies();
			
			waves[currentActiveWave].lastCreatedDate = globalTimer;
			
			if ( waves[currentActiveWave].amountEnemies == waves[currentActiveWave].enemies.length){
				waves[currentActiveWave].keepStopCreating(); 
				//keepCreating va a pasar a false una vez que consegui generar todos los bichos y no va a crear mas
			}
		}
		for(var key in waves[currentActiveWave].enemies)
		{
			
			updImg();
			ctx.drawImage(imagen, //la imagen
					frameIndex * sprwidth / numberOfFrames, // Donde tiene que cortar en px a lo ancho [que frame] * frame ancho / numero de frames que hay
					0, // donde tiene que empezar a cortar a lo alto
					sprwidth / numberOfFrames, //ancho de la imagen total
					sprheight, //alto de la imagen total
					waves[currentActiveWave].enemies[key].posX - 20, //donde lo ubica X
					waves[currentActiveWave].enemies[key].posY - 10, //donce lo ubica Y
					sprwidth / numberOfFrames, //cuan ancho va a dibjuar. el ancho de la imagen / numero de frames / 2 para que quede de 20x20
					sprheight  //cuan alto va a dibjuar. / 2 para que quede de 20x20
					);
			
			if ( waves[currentActiveWave].enemies[key].direction == "horizontal" && 
			typeof waves[currentActiveWave].enemies[key].nextX !== 'undefined')
				{
					(waves[currentActiveWave].enemies[key].nextX - waves[currentActiveWave].enemies[key].posX > 0)? 
					waves[currentActiveWave].enemies[key].posX += waves[currentActiveWave].enemies[key].spd : 
					waves[currentActiveWave].enemies[key].posX -= waves[currentActiveWave].enemies[key].spd;
					
					if ( Math.abs(waves[currentActiveWave].enemies[key].nextX - waves[currentActiveWave].enemies[key].posX) < 
					waves[currentActiveWave].enemies[key].spd) 
					waves[currentActiveWave].enemies[key].posX = waves[currentActiveWave].enemies[key].nextX;
					
					waves[currentActiveWave].enemies[key].nextX == waves[currentActiveWave].enemies[key].posX ? 
					waves[currentActiveWave].enemies[key].direction = "vertical": 
					waves[currentActiveWave].enemies[key].direction ;
				}
			else if ( waves[currentActiveWave].enemies[key].direction == "vertical"	&& 
			typeof waves[currentActiveWave].enemies[key].nextY !== 'undefined')
				{
					(waves[currentActiveWave].enemies[key].nextY - waves[currentActiveWave].enemies[key].posY > 0)? 
					waves[currentActiveWave].enemies[key].posY += waves[currentActiveWave].enemies[key].spd : 
					waves[currentActiveWave].enemies[key].posY -= waves[currentActiveWave].enemies[key].spd;
					
					if ( Math.abs(waves[currentActiveWave].enemies[key].nextY - waves[currentActiveWave].enemies[key].posY) < 
					waves[currentActiveWave].enemies[key].spd) 
					waves[currentActiveWave].enemies[key].posY = waves[currentActiveWave].enemies[key].nextY;
					
					waves[currentActiveWave].enemies[key].nextY == waves[currentActiveWave].enemies[key].posY ? 
					waves[currentActiveWave].enemies[key].direction = "horizontal": 
					waves[currentActiveWave].enemies[key].direction ;
				}
			else;

			if ( waves[currentActiveWave].enemies[key].posY == waves[currentActiveWave].enemies[key].nextY &&
			waves[currentActiveWave].enemies[key].posX == waves[currentActiveWave].enemies[key].nextX && 
			waves[currentActiveWave].enemies[key].movement + 1 < map1.x.length)
				{
					waves[currentActiveWave].enemies[key].movement++;
					waves[currentActiveWave].enemies[key].posX = waves[currentActiveWave].enemies[key].nextX;
					waves[currentActiveWave].enemies[key].posY = waves[currentActiveWave].enemies[key].nextY;
					waves[currentActiveWave].enemies[key].nextX = map1.x[waves[currentActiveWave].enemies[key].movement+1];
					waves[currentActiveWave].enemies[key].nextY = map1.y[waves[currentActiveWave].enemies[key].movement+1];
				}
			
			waves[currentActiveWave].enemies[key].updateHealthBarPosition();
			waves[currentActiveWave].enemies[key].drawEntity();


			if (waves[currentActiveWave].enemies[key].posY > outBoundaries || waves[currentActiveWave].enemies[key].posX > outBoundaries)
				{
					player.reduceLives(waves[currentActiveWave].enemies[key].damage);
					waves[currentActiveWave].enemies.splice(key,1); //la funcion que borra el elemento tiene que estar a lo ultimo del for()
				}

			if(waves[currentActiveWave].enemies.length > 0 && waves[currentActiveWave].enemies[key].health <= 0){
					player.addingMoney(waves[currentActiveWave].enemies[key].gold);
					waves[currentActiveWave].enemies.splice(key,1); //la funcion que borra el elemento tiene que estar a lo ultimo del for()
				}
		} //end for()
		
		if ( waves[currentActiveWave].enemies.length == 0)
		{
			waves[currentActiveWave].setActiveInactive();
			currentActiveWave++;
			//Una vez que todos los enemigos son destruidos o cruzan el camino la wave actual se desactiva y se pasa a la siguiente que se
			//va a activar con un nuevo click
		}
		
	} //end if para wave active
	
	
	for ( var key in towers){
		towers[key].usingNotUsing(); //la pongo en uso, por si el usuario la quiere borrar dentro de este for, que el sistema no lo deje
		towers[key].drawEntity();
		
		if( waves[currentActiveWave] != undefined)
		{
			for(var key2 in waves[currentActiveWave].enemies){
				
				if(towers[key].detectEnemy(waves[currentActiveWave].enemies[key2]))
				{
					if ( towers[key].type != "ice" && new Date().getTime() - towers[key].lastAttack > towers[key].atkSpeed)
					{	
							towers[key].shootBullet(waves[currentActiveWave].enemies[key2]);
							towers[key].lastAttack = new Date().getTime();
					}
				}
				
				for (var key4 in iceTowers){
					if(iceTowers[key4].detectEnemy(waves[currentActiveWave].enemies[key2]))
					{
						waves[currentActiveWave].enemies[key2].slowDownBy(iceTowers[key4].bulletDamage);
						waves[currentActiveWave].enemies[key2].freezeUnfreeze();
						break;
					}
					else
						waves[currentActiveWave].enemies[key2].normalSpeed();
				}
			}
		}
		
		if ( towers[key].type != "ice")
		for(var key3 in towers[key].myBullets)
		{
				towers[key].myBullets[key3].persuitEnemy();
				towers[key].myBullets[key3].drawEntity();
				if(towers[key].myBullets[key3].collideWithEnemy())
					towers[key].myBullets.splice(key3,1);
		}
		towers[key].usingNotUsing(); //la dejo en desuso, la funcion es un switch
	}
	
	
	if ( typeof gTower !== "undefined" && player.optionTowerSelected != "0"){
		switch (player.optionTowerSelected){
			case "1":
				gTower.setRange(75);
				break;
			case "2":
				gTower.setRange(50);
				break;
			case "3":
				gTower.setRange(35);
				break;
		}
		gTower.drawEntity();
	}
	
	globalTimer = (new Date()).getTime();
	
	
}

updImg = function () {

            tickCount += 1;

            if (tickCount > ticksPerFrame) {

				tickCount = 0;
				
                // If the current frame index is in range
                if (frameIndex < numberOfFrames - 1) {	
                    // Go to the next frame
                    frameIndex += 1;
                } else {
                    frameIndex = 0;
                }
            }
        };
		/*
		function writeMessage(canvas, message) {
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.font = '18pt Calibri';
        context.fillStyle = 'black';
        context.fillText(message, 10, 450);
      }
      function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }
      var canvas = document.getElementById('stats');
		var context = canvas.getContext('2d');

		canvas.addEventListener('mousemove', function(evt) {
        var mousePos = getMousePos(canvas, evt);
        var message = 'MP' + mousePos.x + ',' + mousePos.y;
        writeMessage(canvas, message);
      }, false);	
		*/
</script>
</body>
</html>